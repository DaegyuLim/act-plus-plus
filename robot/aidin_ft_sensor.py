# -*- coding: utf-8 -*-
"""testAidin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hvBCYOB2Kq1oWzu5cQMTtD6xEfuN35hx
"""

import struct
import socket
import binascii

IP_ADDR = "192.168.1.199"
LISTEN_PORT = 4001
SENSOR_UDP_PORT = 8890

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

def sendCommand(command):
    sendData = bytearray.fromhex(command)
    s.sendto(sendData, (IP_ADDR, SENSOR_UDP_PORT))

def unpackData(data):
    Fx = struct.unpack('>f', data[0:4])[0]
    Fy = struct.unpack('>f', data[4:8])[0]
    Fz = struct.unpack('>f', data[8:12])[0]
    Tx = struct.unpack('>f', data[12:16])[0]
    Ty = struct.unpack('>f', data[16:20])[0]
    Tz = struct.unpack('>f', data[20:24])[0]
    Ax = struct.unpack('>f', data[24:28])[0]
    Ay = struct.unpack('>f', data[28:32])[0]
    Az = struct.unpack('>f', data[32:36])[0]

    return Fx, Fy, Fz, Tx, Ty, Tz, Ax, Ay, Az

def receiveAndPrintData(data_mask):
    try:
        s.settimeout(5.0)
        command = ''.join(str(x) for x in data_mask)
        sendCommand(command)
        recvData = s.recvfrom(52)[0]

        data_values = [struct.unpack('>f', recvData[i:i+4])[0] for i in range(0, len(recvData), 4) if data_mask[i//4] == 1]
        print(', '.join(f"{data}: {value:.2f}" for data, value in zip(['Fx', 'Fy', 'Fz', 'Tx', 'Ty', 'Tz', 'Ax', 'Ay', 'Az'], data_values)))

    except Exception as e:
        print(f"Error: {e}")

    finally:
        s.close()

def main():
    global s
    s.settimeout(2.0)
    IP = "Sensor IP: " + IP_ADDR
    print(IP)
    PORT = "Sensor UDP PORT: " + str(SENSOR_UDP_PORT)
    print(PORT)

    sendData = input("Enter the data value { ex) 111111100 } : ")
    sendData = int(sendData, 2).to_bytes(2, byteorder='big')
    s.sendto(sendData, (IP_ADDR, SENSOR_UDP_PORT))
    recvData = recvMsg()

    # Initializing
    Fx = Fy = Fz = Tx = Ty = Tz = Ax = Ay = Az = 0

    for i in range(10000):
        recvData = recvMsg()
        Fx, Fy, Fz, Tx, Ty, Tz, Ax, Ay, Az = unpackData(recvData)

        print("Fx : " + str(round(Fx, 2)) + "\n" +
              "Fy : " + str(round(Fy, 2)) + "\n" +
              "Fz : " + str(round(Fz, 2)) + "\n" +
              "Tx : " + str(round(Tx, 2)) + "\n" +
              "Ty : " + str(round(Ty, 2)) + "\n" +
              "Tz : " + str(round(Tz, 2)) + "\n" +
              "Ax : " + str(round(Ax, 2)) + "\n" +
              "Ay : " + str(round(Ay, 2)) + "\n" +
              "Az : " + str(round(Az, 2)))

    s.close()

def recvMsg():
    recvData = s.recvfrom(52)[0]
    print(recvData)
    byte = recvData[0:4]
    print(byte)
    byte_hex = binascii.hexlify(byte)
    print(byte_hex)
    byte_ = struct.unpack('>f', byte)  # big-endian
    print(byte_)

    return byte

if __name__ == "__main__":
    # data_mask_str = input("Input data mask (comma-separated 1s and 0s): ")
    # data_mask = [int(x) for x in data_mask_str.split(',')]
    data_mask = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    receiveAndPrintData(data_mask)
    main()